import 'dart:convert';
import 'dart:math';
import 'dart:typed_data';

import 'package:meta/meta.dart';
import 'package:pointycastle/api.dart';
import 'package:pointycastle/digests/sha256.dart';
import 'package:pointycastle/key_derivators/api.dart';
import 'package:pointycastle/key_derivators/pbkdf2.dart' as pbkdf2;
import 'package:pointycastle/key_derivators/scrypt.dart' as scrypt;
import 'package:pointycastle/block/aes_fast.dart';
import 'package:pointycastle/stream/ctr.dart';
import 'package:pointycastle/macs/hmac.dart';
import 'package:web3dart/src/utils/dartrandom.dart';
import 'package:web3dart/src/utils/uuid.dart';
import 'package:web3dart/web3dart.dart';
import 'package:web3dart/src/utils/crypto.dart' as crypto;
import 'package:web3dart/src/utils/numbers.dart' as numbers;

abstract class _KeyDerivator {

  Uint8List deriveKey(List<int> password);

  String getName();
  Map<String, dynamic> encode();
}

class _PBDKDF2KeyDerivator extends _KeyDerivator {

  final int iterations;
  final Uint8List salt;
  final int dklen;
  
  // The docs (https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition)
  // say that HMAC with SHA-256 is the only mac supported at the moment
  static final Mac mac = new HMac(new SHA256Digest(), 64);

  _PBDKDF2KeyDerivator(this.iterations, this.salt, this.dklen);

  @override
  Uint8List deriveKey(List<int> password) {
    var impl = new pbkdf2.PBKDF2KeyDerivator(mac)
      ..init(new Pbkdf2Parameters(salt, iterations, dklen));

    return impl.process(password);
  }

  @override
  Map<String, dynamic> encode() {
    return {
      'c': iterations,
      'dklen': dklen,
      'prf': 'hmac-sha256',
      'salt': numbers.bytesToHex(salt)
    };
  }

  @override
  String getName() {
    return "pbkdf2";
  }

}

class _ScryptKeyDerivator extends _KeyDerivator {

  final int dklen;
  final int n;
  final int r;
  final int p;
  final List<int> salt;

  _ScryptKeyDerivator(this.dklen, this.n, this.r, this.p, this.salt);

  @override
  Uint8List deriveKey(List<int> password) {
    var impl = new scrypt.Scrypt()
      ..init(new ScryptParameters(n, r, p, dklen, salt));

    return impl.process(password);
  }

  @override
  Map<String, dynamic> encode() {
    return {
      "dklen": dklen,
      "n": n,
      "r": r,
      "p": p,
      "salt": numbers.bytesToHex(salt),
    };
  }

  @override
  String getName() => "scrypt";

}

/// Represents a wallet file. Wallets are used to securetly store credentials
/// like a private key belonging to an Ethereum address. The private key in a
/// wallet is encrypted with a secret password that needs to be known in order
/// to obtain the private key. 
/// 
/// This file supports a limited set of version 3
/// wallet files generated by other ethereum clients, specifically
/// * the key derivation functions p
@immutable
class Wallet {

  /// The credentials stored in this wallet file
  final Credentials credentials;
  /// The key derivator used to obtain the aes decryption key from the password
  final _KeyDerivator _derivator;

  final Uint8List _password;
  final Uint8List _iv;

  final List<int> _id;

  const Wallet._(this.credentials, this._derivator, this._password, this._iv, this._id);

  /// Gets the random uuid assigned to this wallet file
  String get uuid => uuidParser.unparse(_id);

  /// Encrypts the private key using the secret specified earlier and returns
  /// a json representation of its data as a v3-wallet file.
  String toJson() {
    var ciphertextBytes = _encryptPrivateKey();

    var map = {
      'crypto': {
        'cipher': 'aes-128-ctr',
        'cipherparams': {
          'iv': numbers.bytesToHex(_iv)
        },
        'ciphertext': numbers.bytesToHex(ciphertextBytes),
        'kdf': _derivator.getName(),
        'kdfparams': _derivator.encode(),
        'mac': _generateMac(_derivator.deriveKey(_password), ciphertextBytes),
      },
      'id': uuid,
      'version': 3,
    };

    return json.encode(map);
  }

  /// Creates a new wallet wrapping the specified [credentials] by encrypting
  /// the private key with the [password]. The [random] instance, which should
  /// be cryptographically secure, is used to generate encryption keys.
  static Wallet createNew(Credentials credentials, String password, Random random) {
    var passwordBytes = utf8.encode(password);
    var dartRandom = new DartRandom(random);

    var salt = dartRandom.nextBytes(32);
    // TODO Maybe we should let the user controll these parameters?
    var derivator = new _ScryptKeyDerivator(32, 8192, 8, 1, salt);

    var uuid = new Uint8List(16);
    uuidParser.v4(buffer: uuid);

    var iv = dartRandom.nextBytes(128 ~/ 8);

    return new Wallet._(credentials, derivator, passwordBytes, iv, uuid);
  }

  /// Reads and unlocks the wallet denoted in the json string given with the
  /// specified [password]. [encoded] must be the String contents of a valid
  /// v3 Ethereum wallet file.
  static Wallet fromJson(String encoded, String password) {
    /*
      In order to read the wallet and obtain the secret key stored in it, we
      need to do the following: 
      1: Key Derivation: Based on the key derivator specified (either pbdkdf2 or
         scryt), we need to use the password to obtain the aes key used to
         decrypt the private key.
      2: Using the obtained aes key and the iv parameter, decrypt the private
         key stored in the wallet.
    */

    final data = json.decode(encoded);

    // Ensure version is 3, only version that we support at the moment
    final version = data['version'];
    if (version != 3) {
      throw new ArgumentError.value(version, 'version', 'Library only supports '
      'version 3 of wallet files at the moment. However, the following value'
      ' has been given:');
    }

    var crypto = data["crypto"] ?? data["Crypto"];

    String kdf = crypto["kdf"];
    _KeyDerivator derivator;

    switch (kdf) {
      case "pbkdf2":
        var derParams = crypto["kdfparams"];

        if (derParams["prf"] != "hmac-sha256") {
          throw new ArgumentError("Invalid prf supplied with the pdf: was ${derParams["prf"]}, expected hmac-sha256");
        }

        derivator = new _PBDKDF2KeyDerivator(derParams["c"],
          numbers.hexToBytes(derParams["salt"]), derParams["dklen"]);
        
        break;
      case "scrypt":
        var derParams = crypto["kdfparams"];
        derivator = new _ScryptKeyDerivator(derParams["dklen"], derParams["n"],
         derParams["r"],  derParams["p"], numbers.hexToBytes(derParams["salt"])
        );
        break;
      default:
        throw new ArgumentError("Wallet file uses $kdf as key derivation function, which is not supported.");
    }

    // Now that we have the derivator, let's obtain the aes key:
    var encodedPassword = utf8.encode(password);
    var derivedKey = derivator.deriveKey(encodedPassword);
    var aesKey = derivedKey.sublist(0, 16);

    var encryptedPrivateKey = numbers.hexToBytes(crypto["ciphertext"]);

    //Validate the derived key with the mac provided
    var derivedMac = _generateMac(derivedKey, encryptedPrivateKey);
    if (derivedMac != crypto["mac"])
      throw new ArgumentError("Could not unlock wallet file. You either supplied the wrong password or the file is corrupted");

    // We only support this mode at the moment
    if (crypto["cipher"] != "aes-128-ctr") {
      throw new ArgumentError("Wallet file uses ${crypto["cipher"]} as cipher, but only aes-128-ctr is supported.");
    }
    var iv = numbers.hexToBytes(crypto["cipherparams"]["iv"]);

    // Decrypt the private key

    var aes = _initCipher(false, aesKey, iv);

    var privateKey = aes.process(encryptedPrivateKey);
    var credentials = Credentials.fromPrivateKey(numbers.bytesToInt(privateKey));

    // Obtain the uuid of this wallet
    var id = uuidParser.parse(data["id"]);

    return new Wallet._(credentials, derivator, encodedPassword, iv, id);
  }

  static String _generateMac(List<int> dk, List<int> ciphertext) {
    var macBody = <int>[]
      ..addAll(dk.sublist(16, 32))
      ..addAll(ciphertext);
    
    return numbers.bytesToHex(crypto.sha3(macBody));
  }

  static CTRStreamCipher _initCipher(bool forEncryption, List<int> key, List<int> iv) {
    return new CTRStreamCipher(new AESFastEngine())
      ..init(false, new ParametersWithIV(new KeyParameter(key), iv));
  }

  List<int> _encryptPrivateKey() {
    var derived = _derivator.deriveKey(_password);
    var aesKey = derived.sublist(0, 16);

    var aes = _initCipher(true, aesKey, _iv);
    return aes.process(numbers.intToBytes(credentials.privateKey));
  }
}